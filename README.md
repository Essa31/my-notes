# my-notes
Hello my name is Essa Computer science

## Programming languages ​​I learned.
+ python
+ HTML
+ CSS
+ Javascript
## The integrated development environment that I used.
+ pycharm
+ Visual Studio Code
# contact my
you can reacth me through the linkedin [linke](https://github.com/Essa31/my-notes)

I love my profession and my job, and in my spare time I go to movie scenes

![](https://scontent.xx.fbcdn.net/v/t1.15752-9/271998037_1143364519739289_2579221586442460560_n.jpg?_nc_cat=104&ccb=1-5&_nc_sid=aee45a&_nc_eui2=AeF6Kg1GD7YNmF3aHepTdQEnuJdSA4GXnuS4l1IDgZee5Jpb59ZATAKI5o1AQV-KgfGJyvZZhzvmjAbCGVLpHQtk&_nc_ohc=0A8Cn5S5T_IAX_T4qtQ&_nc_oc=AQm-y3y5VZffK9Vpqx7-aA2KQc3jBhH6hVLYg3O_Wu_kEY8v_qnuiQOz5P2-YgRaAoJsf1PgrDTFAPi-Rf3CUDkP&_nc_ad=z-m&_nc_cid=0&_nc_ht=scontent.xx&oh=03_AVLtTBUjN1frg9wetO57ORZ2yuaVIW1G87ESrAAxN6SOcQ&oe=627B2D33)



# Learn the fundamentals of a good developer mindset in 15 minutes

![](https://cdn-media-1.freecodecamp.org/images/0*9aI9Xrj0_SpE9KbK.jpg)

## 1. Conceiving The Purpose of Software
The purpose of programming is to help people. 

 If the developer cannot visualize the goal of the program, he is writing a bad program. 
 
  What is bad software? 
  
   A program that does not help people.  When you supply the work of a program, you have to know how it will benefit people and their future needs

## 2. The Goals of Software Design
However, if you design a bad system, your software’s lifetime will be short.

This brings us to the most important goal of the software design:

## 3. (Mis)understanding
You must understand your work and not workmanship and complex systems do not help and increase the complexity.

## 4. Simplicity
Programming aims to reduce complexity, and bad programmers complicate things and make them complicated for other programmers. Simple things indicate the developer's intelligence and skills.  And that the complexity of things does not indicate intelligence, but leads to failure sometimes and causes the new developers to not understand your program

## 5. Complexity
I am developing a simplified plan to work on it in a way that does not ramify and expand in a complex without reason that leads to a program working well.  And when you add complications that cause new complications and small changes become difficult, know that you have entered the stage of rewriting the code from the beginning.  In order to fix this problem, you must
First, you will exactly know your software purpose and its definition. Second, you will be as simple as possible in every piece of code you write. Third, when a new feature or change request comes to the discussion table, you will evaluate them based on your software purpose and question them.

## 6. Maintenance
Maintenance is more important than fast coding and fast charging, a fact that some developers ignore.  Thinking about future maintenance of changes is one of your main responsibilities as a developer.  Maintenance depends on simplicity and complexity, where the ease of maintenance of any part of the program is proportional to the simplicity of the individual piece, and the effort of maintenance is proportional to the complexity of the program.
The one rule that you should follow about maintenance is: It is more important to reduce the effort of maintenance than it is to reduce the effort of implementation.

## 7. Consistency
Consistency is if the top does something in a way, then do that in the same way everywhere. If the code is not consistent, it is difficult to understand and this leads to problems as we mentioned earlier

## 8. Prioritizing
If you do not know how to make decisions about your program and if it faces many directions and you have to choose which one you should focus on and what you should implement.  There are three important factors that will help you in making a decision.

1.The desirability of a change (D): How much do you want that change to happen?

2.The value of a change (V): How much value does the change offer? How much does it help your users?

3.The effort required to perform the change (E): How much work will you need to do to accomplish this change?

The equation is simple: D=V/E

The desirability of any change is directly proportional to the value of the change and inversely proportional to the effort involved in making the change.


The equation is simple: D=V/E

The desirability of any change is directly proportional to the value of the change and inversely proportional to the effort involved in making the change.

## 9. Solving Problems
There are three steps to problem solving.
  1. I understand the problem, because the reason why no problem is solved is the lack of understanding it. 
   2. Plan to solve the problem and take the time without wasting time.
  3. The division of the big problem, except for the small problems.
## 10. Good enough is fine
The pursuit of perfection while undertaking a project and planning exaggerations lead to
You will be writing code that isn’t needed
You will increase complexity by adding unnecessary codes
You will be too generic
You will be missing deadlines
You will be dealing with many bugs caused by the complexity
To avoid that, you have to start small, improve it, and then expand
The incremental design should be your guide. Here is how you would use it to design a calculator:

1.Plan a system that does only addition and nothing else.

2.Implement it.

3.Improve the now-existing system’s design so you can add other operations also.

4.Plan subtraction and repeat step 2 and 3.

5.Plan multiplication and repeat step 2 and 3.

6.Plan division and repeat step 2 and 3.

## 11. Predictions

A prediction is simply a forecast that something will happen in the future. It could be factual and based on some kind of objective data or it could be based on an assumption.
Being too generic involves a lot of code that isn’t needed.

## 12. Assumptions

“An assumption is something that you accept as true or suppose to be true, although you have no conclusive proof.”
You should not worry about the future and do not seek comprehensiveness in writing your program and be interested in solving problems from a more rational perspective.

Follow this rule

Code should be designed based on what you know now, not on what you think will happen in the future

## 13. Stop Reinventing

Code should be designed based on what you know now, not on what you think will happen in the future

You need something that doesn’t exist yet.
All of the existing “wheels” are bad technologies or incapable of handling your needs.
The existing “wheels” aren’t being properly maintained.

## 14. Resistance

Resist change as much as possible and don't accept it unless it is necessary

Go back and remember your software purpose. Then remember the simple equation in prioritizing section.

## 15. Automation

Don't waste your time with repetitive tasks, you can make it work automatically without getting tired

## 16. Code measurement

I am a number of codes is not a measure of quality. The code that has been less likely to be better

The short code may be more complicated than long so you should find balance

The optimum code is a small bunch of code that is easy to understand, easy to read.

## 17. Productivity

Productivity can be measured by removing as much code as possible.

## 18. Testing

You must test the code periodically and not guess the source of the error and apply based on your assumption and you must also be reliable in order to increase the confidence of employees in you and remember:

Untested code is the code that doesn’t work.

## 19. (Under)Estimation

Some programmers miscalculate the time and effort required for me to write some code, which leads to missing deadlines.  To solve this problem, you need to divide the problem into smaller problems

## 20. Running Away From Rewriting

If you make a mistake and you want to re-write the code, then wait. Perhaps this is an illusion and not the solution in most cases. This often happens because sometimes it is difficult for us to read the code instead of writing it.  Don't forget to tip.
Refactoring should be the first option.

## 21. Documentation and Commenting

The comment is not added to the code to make it clear what it does. It is used. If you cannot simplify the code in this case, you can use it. Documentation is important to explain the structure of the program so that we can see the comprehensive pictures of it and to help new members of the team understand it in a faster way.

## 22. Picking Technologies (Tools, Libraries, etc.)

Don’t depend on external technologies. But when you have to do so, try to reduce your dependency on them as much as you can.

Because it may increase the complexity in some stages and this technology may contain errors that make you stuck.  So you have to choose.  Appropriate technique wisely

There are a few factors you should consider before you start using some technology:

Is there active development behind it?
Will it continue to be maintained?
How easy is it to switch away from?
What does the community say about it?

## 23. Self-Development

Keep learning from different sources and try different programming languages ​​and you will find yourself constantly improving. Use the right technology in the right place and know that every problem has a solution.

## 24. Don’t be a hero

We have to know when to give up, we are human in the end

## 25. Don’t Ask Questions… Ask For Help

When you face a problem and want to do something, try all the solutions before asking for help because it is a better way to learn because sometimes you do not know your true abilities